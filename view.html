<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View GPT (Optimized Exclusion Lazy Load & Full Comments)</title>

    <script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>
    <script>
        // ------------------------------------------------------------------
        // [GAM 전역 네임스페이스 초기화]
        //
        // - window.googletag: GAM(Google Publisher Tag)에서 사용하는 전역 객체입니다.
        // - cmd 배열:
        //   · GPT 라이브러리가 완전히 로드되기 전까지 실행해야 하는 설정 함수들을
        //     큐에 쌓아두는 역할을 합니다.
        //   · 외부 스크립트(gpt.js)가 로드되면, cmd에 쌓인 함수들을 순차적으로 실행합니다.
        //   · 따라서, googletag 관련 코드는 항상 googletag.cmd.push(function() { ... }) 안에
        //     작성해야 합니다. (로드 타이밍 이슈 방지)
        // ------------------------------------------------------------------
        window.googletag = window.googletag || { cmd: [] };

        // ------------------------------------------------------------------
        // 1. 광고 단위 경로 (Ad Unit Path)
        //
        // - AdUnitPath는 GAM 인벤토리 상의 광고 단위(Ad Unit)를 식별하는 "경로"입니다.
        //   예: /네트워크코드/사이트/섹션
        //   여기서는 /7450/www.mk.co.kr/news/economy 를 사용합니다.
        // ------------------------------------------------------------------
        const AdUnitPath = '/7450/www.mk.co.kr/news/economy';

        // ------------------------------------------------------------------
        // 다크 모드 여부 감지
        //
        // - 'prefers-color-scheme: dark' 미디어쿼리 결과를 기반으로
        //   is_dark_mode 키를 GAM에 전달합니다.
        // ------------------------------------------------------------------
        const isDarkMode = window.matchMedia &&
            window.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'true' : 'false';

        // ***************************************************
        // ✅ 광고 렌더링 완료 시 'Advertisement' 라벨을 삽입하는 함수 (GAM 이벤트 리스너)
        //
        // - GAM의 slotRenderEnded 이벤트에 연결되는 공통 핸들러입니다.
        // - 역할:
        //   · 납품된 광고(비어 있지 않은 슬롯)에 한해 "Advertisement" 라벨을 자동으로 삽입합니다.
        //   · 슬롯마다 HTML에 라벨을 직접 하드코딩하지 않고, 광고가 실제로 렌더링된 경우에만
        //     라벨을 노출함으로써 "빈 슬롯에 라벨만 떠 있는 상황"을 피합니다.
        //
        // - 예외 처리:
        //   · BC_native_list_* 슬롯은 에디토리얼 뉴스 리스트와 자연스럽게 섞이는
        //     Native 형태이므로, 리스트 UI에서 별도 "Advertisement" 라벨을 붙이지 않습니다.
        //   · TC_billboard_X(상단 빌보드)는 "Advertisement" 라벨을 붙이지 않는 예외 슬롯으로 처리합니다.
        // ***************************************************
        function addAdLabel(event) {
            const slotId = event.slot.getSlotElementId();

            // 💡 [예외] 우측 '이 시각 주요 뉴스' Native 슬롯 + 상단 TC 빌보드에는 라벨을 붙이지 않음
            if (
                slotId === 'BC_native_list_1' ||
                slotId === 'BC_native_list_2' ||
                slotId === 'TC_billboard_X'
            ) {
                return;
            }

            const slotElement = document.getElementById(slotId);

            // - event.isEmpty === false: GAM이 이 슬롯에 실제 크리에이티브를 반환했다는 의미입니다.
            // - slotElement 존재 여부: DOM 상에 해당 id를 가진 요소가 실제 존재하는지 이중 확인합니다.
            if (event.isEmpty === false && slotElement) {
                const outerSlot = slotElement.closest('.ad-slot');
                if (!outerSlot) return;

                // 이미 라벨이 존재하면 중복 삽입 방지
                if (outerSlot.querySelector('.mk-ad-label')) return;

                const labelElement = document.createElement('div');
                labelElement.className = 'mk-ad-label';
                labelElement.textContent = 'Advertisement';

                // 광고 div의 가장 위에 라벨 요소를 삽입합니다.
                outerSlot.insertBefore(labelElement, outerSlot.firstChild);

                // 슬롯 테두리/배경은 투명 처리(디자인 레벨에서 컨트롤)
                outerSlot.style.border = 'none';
                outerSlot.style.backgroundColor = 'transparent';

                console.log(`✅ [Ad Label] Label added for ${slotId}`);
            }
        }
        // ***************************************************

        // ------------------------------------------------------------------
        // [GAM 초기화 블록]
        // ------------------------------------------------------------------
        googletag.cmd.push(function () {

            // --- [1] device_category 결정 (페이지 레벨 공통 타게팅) -----------------
            //
            // - UA(User Agent)와 viewport 폭을 결합하여 디바이스를 3단계로 구분합니다.
            //   1. smartphone : 스마트폰용 UA 문자열이 포함되어 있거나, 화면 폭이 768px 이하인 경우
            //   2. tablet     : 스마트폰은 아니지만 태블릿용 UA 문자열이 포함되어 있거나, 화면 폭이 1024px 이하인 경우
            //   3. desktop    : 위 조건에 해당하지 않는 모든 경우 (기본값)
            //
            // - 이 값은 슬롯 정의 여부(if 조건)와 GAM 타게팅 값(device_category)으로 활용됩니다.
            // ------------------------------------------------------------------
            const userAgent = navigator.userAgent.toLowerCase();
            const width = window.innerWidth;
            let deviceCategory = 'desktop';

            // 1. Smartphone 판별: 모바일 UA(iPad 제외)이거나 폭이 768px 이하인 경우
            if ((/mobile|android|iphone|ipod/.test(userAgent) && !/ipad/.test(userAgent)) || width <= 768) {
                deviceCategory = 'smartphone';
            } 
            // 2. Tablet 판별: iPad/Tablet UA이거나 폭이 1024px 이하인 경우
            else if (/ipad|tablet/.test(userAgent) || width <= 1024) {
                deviceCategory = 'tablet';
            }
            // 3. 그 외: 기본값 desktop 유지

            // ------------------------------------------------------------------
            // [페이지 레벨 키/값 설정 – 공통 타게팅]
            // ------------------------------------------------------------------
            googletag.pubads().setTargeting('device_category', deviceCategory);

            // 기본 예시(고정 값)
            googletag.pubads().setTargeting('page_type', 'view');
            googletag.pubads().setTargeting('section_front_nm', 'economy');
            googletag.pubads().setTargeting('is_dark_mode', isDarkMode);
            googletag.pubads().setTargeting('gpt_version', '2025');
            googletag.pubads().setPublisherProvidedId('PPID_DYNAMIC_HASHED_ID (SERVER_HASHED_ID)');

            // ▼▼▼ 동적 입력 키-값 (실제 운영 시 CMS 치환) ▼▼▼
            googletag.pubads().setTargeting('domain', window.location.hostname);
            googletag.pubads().setTargeting('url', window.location.href);
            // ... (기타 동적 타게팅 키값은 기존 코드와 동일) ...
            // ▲▲▲ 동적 입력 키-값 ▲▲▲

            // ✅ GAM 이벤트 리스너 추가
            googletag.pubads().addEventListener('slotRenderEnded', addAdLabel);

            // ------------------------------------------------------------------
            // 0. Size Mapping 정의 – 반응형 광고 사이즈 정책(3개로 분리 적용)
            // ------------------------------------------------------------------
            
            // 0-1. 가로형 배너용 사이즈 매핑 (TC)
            const sizeMapping_horizontal = googletag.sizeMapping()
                .addSize([1024, 0], [
                    [1246, 100], [1200, 300], [1200, 100], 
                    [980, 120], [970, 250], [930, 180], [970, 90], 
                    [728, 90], 
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .addSize([768, 0], [
                    [750, 300], [750, 200], [728, 90], 
                    [480, 320], 
                    [336, 280], [320, 480], [300, 250], 
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .addSize([0, 0], [
                    [336, 280], [320, 480],
                    [320, 100], [320, 50], 
                    [300, 250], [250, 250], [200, 200], 
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .build();

            // 0-2. 우측 사이드레일 박스형 배너용 사이즈 매핑 (MR)
            const sizeMapping_siderail_square = googletag.sizeMapping()
                .addSize([1024, 0], [
                    [336, 280], [320, 480], [300, 600], [300, 250], 
                    [250, 250], [200, 200],
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .addSize([768, 0], [
                    [480, 320], 
                    [336, 280],[320, 480],
                    [320, 100], [320, 50],
                    [300, 250], [250, 250], [200, 200],
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .addSize([0, 0], [
                    [336, 280], [320, 480],
                    [320, 100], [320, 50],
                    [300, 250], [250, 250], [200, 200],
                    [2, 1], [1, 1], 
                    'fluid'
                ])
                .build();

            // 0-3. 본문 박스형 배너용 사이즈 매핑 (MC)
            const sizeMapping_article_horizontal = googletag.sizeMapping()
                .addSize([1024, 0], [
                    [480, 320], [336, 280],[320,480], 
                    [320, 100], [320, 50],
                    [300, 250],
                    [300, 251], [300, 252], [300, 253], [300, 254], [300, 255], [300, 256], [300, 257], [300, 258],
                    [250, 250],[200, 200],
                    [2, 1], [1, 1], 'fluid'
                ])
                .addSize([768, 0], [
                    [480, 320], [336, 280], [320,480], 
                    [320, 100], [320, 50],
                    [300, 250],
                    [300, 251], [300, 252], [300, 253], [300, 254], [300, 255], [300, 256], [300, 257], [300, 258],
                    [250, 250], [200, 200],
                    [2, 1], [1, 1], 'fluid'
                ])
                .addSize([0, 0], [
                    [336, 280], [320, 480],
                    [320, 100], [320, 50],
                    [300, 250],
                    [300, 251], [300, 252], [300, 253], [300, 254], [300, 255], [300, 256], [300, 257], [300, 258],
                    [250, 250], [200, 200],
                    [2, 1], [1, 1], 'fluid'
                ])
                .build();


            // ------------------------------------------------------------------
            // 5. 광고 슬롯 변수 초기화
            // ------------------------------------------------------------------
            let TC_billboard_X_slot = null;
            let MR_side_rail_X_slot = null;
            let MC_article_rectangle_1_slot = null;
            let MC_article_rectangle_2_slot = null;
            let MC_article_rectangle_3_slot = null;
            let MC_article_rectangle_4_slot = null;
            let MC_article_rectangle_5_slot = null;
            let MC_article_rectangle_6_slot = null;
            let MC_article_rectangle_7_slot = null;
            let MC_article_rectangle_8_slot = null;

            // ------------------------------------------------------------------
            // 5-1. TC_billboard_X (Eager Load, ATF)
            // 💡 [수정 작업 2] 기존 desktop, tablet 호출에서 -> desktop 일때만 호출되도록 수정
            // ------------------------------------------------------------------
            if (deviceCategory === 'desktop') {
                TC_billboard_X_slot = googletag.defineSlot(
                    AdUnitPath, 
                    [[1246, 100], [1200, 300], [1200, 100], [980, 120], [970, 250], [970, 90], [930, 180], [728, 90], [2, 1], [1, 1], 'fluid'], 
                    'TC_billboard_X'
                )
                    .defineSizeMapping(sizeMapping_horizontal)
                    .setTargeting('div_id', 'TC_billboard_X')
                    .setTargeting('position', 'TC')
                    .setTargeting('ad_area_type', 'ATF')
                    .setTargeting('default_exposure', '')
                    .setTargeting('load_type', 'eager')
                    .addService(googletag.pubads());
            }

            // ------------------------------------------------------------------
            // 5-2. MR_side_rail_X (ATF)
            // 💡 [수정 작업 3] 'load_type'을 'lazy'에서 'eager'로 수정 (Desktop 전용)
            // ------------------------------------------------------------------
            if (deviceCategory === 'desktop') {
                MR_side_rail_X_slot = googletag.defineSlot(AdUnitPath, 
                    [[336, 280],[320, 480], [300, 600], [300, 250], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 
                    'MR_side_rail_X'
                )
                    .defineSizeMapping(sizeMapping_siderail_square)
                    .setTargeting('div_id', 'MR_side_rail_X')
                    .setTargeting('position', 'MR')
                    .setTargeting('ad_area_type', 'ATF')
                    .setTargeting('default_exposure', '')
                    .setTargeting('load_type', 'eager') // 💡 Eager로 변경됨
                    .addService(googletag.pubads());
            }

            // ------------------------------------------------------------------
            // 5-3 ~ 5-10. MC in-article 슬롯 (모두 Lazy Load)
            // - ad_area_type = 'in_article'
            // ------------------------------------------------------------------
            MC_article_rectangle_1_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 251], [250, 250], [200, 200],  [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_1')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_2_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 252], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_2')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_3_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 253], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_3')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_4_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 254], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_4')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_5_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 255], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_5')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_6_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 256], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_6')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_7_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 257], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_7')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            MC_article_rectangle_8_slot = googletag.defineSlot(AdUnitPath, [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [300, 258], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'], 'MC_article_rectangle_8')
                .defineSizeMapping(sizeMapping_article_horizontal).setTargeting('position', 'MC').setTargeting('ad_area_type', 'in_article').setTargeting('load_type', 'lazy').addService(googletag.pubads());

            // ------------------------------------------------------------------
            // 5-11. BC_byline_rectangle (Lazy Load)
            // ------------------------------------------------------------------
            const BC_byline_rectangle_slot = googletag.defineSlot(
                AdUnitPath,
                [[750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [320, 100], [320, 50], [300, 250], [250, 250], [200, 200], [2, 1], [1, 1], 'fluid'],
                'BC_byline_rectangle'
            )
                .defineSizeMapping(sizeMapping_horizontal)
                .setTargeting('div_id', 'BC_byline_rectangle')
                .setTargeting('position', 'BC')
                .setTargeting('ad_area_type', 'below_byline')
                .setTargeting('default_exposure', '')
                .setTargeting('load_type', 'lazy')
                .addService(googletag.pubads());

            // ------------------------------------------------------------------
            // 5-12. BC_billboard_rectangle (Lazy Load)
            // ------------------------------------------------------------------
            const BC_billboard_rectangle_slot = googletag.defineSlot(
                AdUnitPath,
                [[1246, 100], [1200, 300], [1200, 100], [980, 120], [970, 250], [970, 90], [930, 180], [750, 300], [750, 200], [728, 90], [480, 320], [336, 280], [320, 480], [300, 250], [250, 250], [200, 200], [320, 100], [320, 50], [2, 1], [1, 1], 'fluid'],
                'BC_billboard_rectangle'
            )
                .defineSizeMapping(sizeMapping_horizontal)
                .setTargeting('div_id', 'BC_billboard_rectangle')
                .setTargeting('position', 'BC')
                .setTargeting('ad_area_type', 'below_comments')
                .setTargeting('load_type', 'lazy')
                .addService(googletag.pubads());

            // ------------------------------------------------------------------
            // 5-13, 5-14. BC_native_list_1/2
            // 💡 [수정 작업 1] 데스크톱일 때도 기본 호출되도록 if 조건문 제거
            // 💡 'load_type'을 디바이스에 따라 동적 설정: Desktop이면 'eager', 아니면 'lazy'
            // ------------------------------------------------------------------
            const BC_native_list_1_slot = googletag.defineSlot(
                AdUnitPath,
                [[320, 100], [320, 50], [1, 1], 'fluid'],
                'BC_native_list_1'
            )
                .setTargeting('div_id', 'BC_native_list_1')
                .setTargeting('position', 'BC')
                .setTargeting('ad_area_type', 'in_related_news')
                .setTargeting('default_exposure', 'hidden')
                .setTargeting('load_type', deviceCategory === 'desktop' ? 'eager' : 'lazy')
                .addService(googletag.pubads());

            const BC_native_list_2_slot = googletag.defineSlot(
                AdUnitPath,
                [[320, 100], [320, 50], [2, 1], 'fluid'],
                'BC_native_list_2'
            )
                .setTargeting('div_id', 'BC_native_list_2')
                .setTargeting('position', 'BC')
                .setTargeting('ad_area_type', 'in_related_news')
                .setTargeting('default_exposure', 'hidden')
                .setTargeting('load_type', deviceCategory === 'desktop' ? 'eager' : 'lazy')
                .addService(googletag.pubads());

            // ------------------------------------------------------------------
            // 6. GAM 핵심 기능 & PageSettingsConfig 설정 (최신화)
            // 💡 [수정 작업 4] 메서드 호출을 setConfig 하나로 통합
            // ------------------------------------------------------------------
            googletag.setConfig({
                // 1. Single Request Architecture 활성화 (지원 중단된 enableSingleRequest 대체)
                singleRequest: true, 
                
                // 2. 초기 로딩 방지 (IntersectionObserver 기반 Lazy Load 필수 설정 - disableInitialLoad 대체)
                disableInitialLoad: true,
                
                // 3. 광고 iframe 중앙 정렬
                centering: true,
                
                // 4. 광고 요청 전 빈 슬롯 접기 (CLS 방지 및 공간 최적화)
                collapseDiv: 'BEFORE_FETCH'
            });

            // 설정 후 서비스 활성화
            googletag.enableServices();

            // ------------------------------------------------------------------
            // [Eager Load 처리] – 데스크탑 TC_billboard_X
            // - TC_billboard_X_slot이 정의된 경우에만 refresh()를 호출합니다.
            // ------------------------------------------------------------------
            googletag.cmd.push(function () {
                if (TC_billboard_X_slot) {
                    googletag.pubads().refresh([TC_billboard_X_slot]);
                }
            });
        });
    </script>

    <style>
        /* [기존 View Mockup 스타일 유지]
           - 이 영역은 기사 본문/레이아웃 전반에 대한 스타일을 정의합니다.
           - 광고 관련 CSS는 별도 주석으로 설명을 덧붙였습니다.
        */
        body {
            font-family: 'Malgun Gothic', 'Dotum', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #fff;
            color: #333;
        }
        a { text-decoration: none; color: inherit; }

        /* --------------------------------------------------------------
           [페이지 공통 너비 정책 – 1246px 컨테이너]
        -------------------------------------------------------------- */
        .container { max-width: 1246px; margin: 0 auto; padding: 0 15px; }

        nav { background-color: #f9f9f9; border-bottom: 1px solid #333; margin-bottom: 20px; }
        .nav-list { list-style: none; padding: 0; margin: 0; display: flex; justify-content: flex-start; }
        .nav-list li { padding: 15px 15px; font-size: 14px; color: #555; }
        .nav-list .current { color: #c00; font-weight: bold; }

        .like-share-section {
            margin-bottom: 20px;
        }

        .content-wrap {
            display: flex;
            gap: 25px;
            margin-bottom: 30px;
            z-index: 5;
        }
        .article-area {
            flex: 3;
            min-width: 0;
            z-index: 5;
        }

        /* ------------------------------------------------------------------
           우측 관련 영역 (.related-area) – 데스크탑/모바일 공통 기본값
        ------------------------------------------------------------------ */
        .related-area {
            flex: 1;
            z-index: 5;
            position: sticky;
            top: 20px;
            height: fit-content;
            /* padding 없음 – 우측 레일 폭을 100% 광고에 사용하기 위한 공통 정책 */
        }

        .sidebar {
            padding: 0;
            box-sizing: border-box;
        }

        .sidebar-box {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
            padding: 0; /* ✅ 광고 슬롯이 직접 들어가는 컨테이너에는 padding을 주지 않는 공통 규칙 */
        }

        .article-body img {
            max-width: 100%;
            height: auto;
        }

        .article-header h1 {
            font-size: 32px;
            line-height: 1.3;
            margin: 20px 0 10px 0;
            font-weight: 700;
        }
        .article-byline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #777;
        }

        .article-body { font-size: 17px; line-height: 1.8; word-break: keep-all; margin-bottom: 40px; }
        .article-body p { margin-bottom: 1.5em; text-indent: 1em; }
        .article-image { text-align: center; margin: 25px 0; }

        /* 데이터 박스 */
        .dummy-data-box {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
            font-size: 15px;
            line-height: 1.6;
        }

        /* YouTube 등 Embeds */
        .article-embed {
            margin: 25px 0;
        }
        .embed-wrapper {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 */
            height: 0;
            overflow: hidden;
            max-width: 100%;
        }
        .embed-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .embed-caption {
            font-size: 13px;
            color: #888;
            margin-top: 5px;
        }

        /* ------------------------------------------------------------------
           [광고 공통 컨테이너: .ad-slot]
        ------------------------------------------------------------------ */
        .ad-slot {
            background-color: transparent;
            color: transparent;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            font-size: 14px;
            font-weight: bold;
            box-sizing: border-box;
            border: none;
            transition: background-color 0.5s ease;
            width: 100%;    /* 부모 컨테이너(기사 본문/우측 컬럼/바이라인 등)의 폭을 100% 사용 */
            height: auto;   /* 높이는 실제 크리에이티브/iframe에 의해 결정 */
            position: relative;
            z-index: 10;
            padding-top: 10px; /* 라벨/크리에이티브와 상단 요소 간 최소 간격 확보 */
        }

        /* in-article 및 테스트 시각화를 위한 임시 스타일 */
        .ad-mc-article {
            background-color: #f9f9f9;
            color: #ccc;
            opacity: 0.8;
            border: 1px solid #ccc;
        }

        /* 광고 로딩 여부를 눈으로 확인하고 싶을 때 부여하는 클래스 (옵션) */
        .ad-loaded {
            background-color: #c00 !important;
            color: #fff;
            opacity: 1;
            box-shadow: 0 0 15px rgba(192, 0, 0, 0.5);
        }

        /* ------------------------------------------------------------------
           [Advertisement 라벨 스타일: .mk-ad-label]
        ------------------------------------------------------------------ */
        .mk-ad-label {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 0;
            background-color: transparent;
            color: #5A5A5A;
            font-size: 13px;
            font-weight: normal;
            text-transform: uppercase;
            line-height: 1;
            white-space: nowrap;
        }

        .related-box {
            margin-bottom: 20px;
        }

        .comment-section {
            margin-bottom: 20px;
        }

        /* ------------------------------------------------------------------
           Native 광고용 LI 컨테이너 (.native-ad-list-item)
           - 💡 [수정 작업 1 관련] Desktop에서도 노출해야 하므로 기존의 display: none (기본값) 정책 수정
           - 기본적으로 display: flex를 유지하고, 미디어쿼리 제한을 해제함
        ------------------------------------------------------------------ */
        .native-ad-list-item {
            display: flex; /* 💡 수정: 기본값 flex로 변경하여 데스크탑 노출 허용 */
            align-items: center;
            justify-content: center;
            text-align: center;
            border: none;
            background-color: transparent;
            color: inherit;
            padding: 0;
            margin: 0;
            font-weight: normal;
            font-size: 15px;
            width: 100%;   /* 부모 UL(li) 폭을 그대로 사용 */
            height: auto;
            overflow: visible;
            transition: none;
            list-style-type: none;
        }

        /* 기존 인기뉴스(좌측) 스타일 – 참고용 */
        .popular-news-list {
            list-style-type: disc;
            padding-left: 20px;
        }
        .popular-news-list li {
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        /* ------------------------------------------------------------------
           이 시각 주요 뉴스 리스트 스타일링 (.related-list)
        ------------------------------------------------------------------ */
        .related-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
            counter-reset: hotNewsRank;
            border-top: 1px solid #e5e5e5;
        }
        .related-list li {
            position: relative;
            padding: 10px 0 12px 0; /* 기본: 좌측 패딩 없음, 세로 여백만 */
            font-size: 14px;
            line-height: 1.5;
        }
        .related-list li + li {
            border-top: 1px solid #e5e5e5;
        }

        /* 기사 LI(번호 표시 대상)에만 번호/좌측 패딩 적용 */
        .related-list li.article-item {
            padding-left: 26px; /* 좌측 번호 영역 확보 */
        }

        /* 기본: 기사 LI(.article-item)에 대해서만 카운터 증가 + 숫자 노출 */
        .related-list li.article-item::before {
            counter-increment: hotNewsRank;
            content: counter(hotNewsRank);
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            font-weight: 700;
            font-size: 16px;
            color: #111;
        }

        /* Native 광고 LI: 카운터 증가 X, 화면상 라벨/번호 없음 */
        .related-list .native-ad-list-item::before {
            counter-increment: none;  /* 기사 카운트에 영향 없음 */
            content: "";
        }

        .related-list li a {
            font-size: 14px;
            line-height: 1.5;
            display: block;
        }

        /* Native LI도 기사와 동일한 세로 간격만 유지하고, 좌측 패딩은 0 */
        .related-list .native-ad-list-item {
            padding: 10px 0 12px 0;
        }

        .related-list li a:hover {
            text-decoration: underline;
        }

        /* ------------------------------------------------------------------
           디바이스별 광고 노출 제어 – .ad-tc, .ad-mr
           - ad-tc: 상단 TC 빌보드 그룹
           - ad-mr: 우측 MR 사이드 레일 그룹
        ------------------------------------------------------------------ */
        .ad-tc,
        .ad-mr {
            display: none;
        }

        /* ------------------------------
           데스크탑 레이아웃 (>= 1025px)
           - 우측 컬럼 최소 336px 확보
           - MR_side_rail_X 노출
        ------------------------------ */
        @media (min-width: 1025px) {
            .ad-tc {
                display: flex;
            }
            #MR_side_rail_X {
                display: flex;
            }

            /* 우측 컬럼: 최소 336px 확보 */
            .related-area {
                flex: 0 1 336px;
                min-width: 336px;
                width: auto;
            }

            /* 기사 본문 영역은 나머지 가용 폭을 유연하게 사용 */
            .article-area {
                flex: 1 1 auto;
                min-width: 0;
            }
        }

        /* ------------------------------
           태블릿/모바일 레이아웃 (<= 1024px)
           - 우측 컬럼 아래로 내려오고 폭 100%
        ------------------------------ */
        @media (max-width: 1024px) {
            .content-wrap {
                flex-direction: column;
            }
            .related-area {
                width: 100%;
                max-width: none;
                position: static;
            }
            
            /* Native LI 노출 제어는 위쪽 기본값(display: flex)으로 통일됨 */
        }

        /* ------------------------------------------------------------------
           다크 모드 지원
        ------------------------------------------------------------------ */
        @media (prefers-color-scheme: dark) {
            body { background-color: #1a1a1a; color: #e0e0e0; }
            a { color: #ccc; }
            nav { background-color: #1a1a1a; border-bottom-color: #444; margin-bottom: 20px; }
            .nav-list li { color: #ccc; }
            header { background-color: #1a1a1a; border-bottom-color: #444; }
            .logo { color: #fff !important; }

            .article-header h1 { color: #e0e0e0; }
            .article-byline { border-bottom-color: #333; color: #999; }
            .article-body,
            .article-body p { color: #ccc; }
            .article-area h2,
            .extra-content-section h3,
            .related-box h4 { color: #e0e0e0 !important; }
            .dummy-data-box { background-color: #222; border-color: #444; color: #ccc; }
            .comment-section h3 { color: #e0e0e0; }
            .comment-item { border-bottom-color: #333 !important; }

            .related-box,
            .related-list { background-color: #1a1a1a !important; }
            .extra-content-section { border-top-color: #444; }
            .extra-content-section h3 { border-left-color: #c00 !important; }
            .popular-news-list li { border-bottom-color: #333; }
            .shorts-item { background-color: #222; }
            .native-ad-list-item {
                background-color: transparent;
                border: none;
                color: inherit;
            }

            .related-list { border-top-color: #333; }
            .related-list li + li { border-top-color: #333; }

            .ad-mc-article {
                background-color: #333;
                color: #ccc;
            }

            .embed-caption { color: #aaa; }

            /* ✅ 다크 모드에서 광고 라벨 대비 강화 */
            .mk-ad-label {
                background-color: rgba(0, 0, 0, 0.7);
                color: #f5f5f5;
                box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
                font-weight: normal;
            }

            /* ✅ 다크 모드에서 "이 시각 주요 뉴스" 번호 컬러 반전 */
            .related-list li.article-item::before {
                color: #f5f5f5;
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="container">
            <div style="font-size: 20px; font-weight: bold; padding: 10px 0;" class="logo">View GPT</div>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul class="nav-list">
                <li>HOME</li>
                <li class="current">경제</li>
                <li>IT/과학</li>
                <li>부동산</li>
                <li>오피니언</li>
            </ul>
        </div>
    </nav>

    <div class="container">

        <div id="TC_billboard_X" class="ad-slot ad-tc">
            <script>
                googletag.cmd.push(function () {
                    if (typeof TC_billboard_X_slot !== 'undefined' && TC_billboard_X_slot !== null) {
                        googletag.display('TC_billboard_X');
                    }
                });
            </script>
        </div>

        <div class="content-wrap">
            <div class="article-area">

                <header class="article-header">
                    <h1>글로벌 AI 반도체 시장 격변, K-칩스 초격차 전략 시급</h1>
                </header>
                <div class="article-byline">
                    <span class="journalist">김기자 (kim.j@mk.com)</span>
                    <span class="datetime">입력 2025.10.31. 10:00:00</span>
                </div>

                <div class="article-body">
                    <p><strong>[서론]</strong> 최근 인공지능(AI) 산업의 폭발적인 성장과 함께 AI 반도체 시장을 선점하기 위한 글로벌 경쟁이 격화되고 있습니다. 특히 거대 기술 기업들(빅테크)이 자체 칩 개발에 속도를 내면서, 전통적인 반도체 강국인 우리나라에도 변화와 위협이 동시에 다가오고 있습니다. 한국 반도체 기업들은 메모리 분야의 압도적인 우위를 바탕으로 비메모리 분야까지 영역을 확장하여 <strong>'K-칩스' 초격차 전략</strong>을 시급히 마련해야 한다는 목소리가 높습니다。</p>

                    <div class="article-image">
                        <img src="https://placehold.co/800x400/333/fff?text=기술+심층+분석+자료" alt="기술 분석 자료 이미지">
                        <p style="font-size: 13px; color: #888; margin-top: 5px;">기술 동향 및 투자 규모 분석 그래프</p>
                    </div>

                    <p><strong>[본문 1: 시장 재편과 한국의 위치]</strong> AI 반도체 시장은 CPU, GPU 등 기존 프로세서와는 달리 대규모 병렬 연산에 최적화된 NPU를 중심으로 재편되고 있습니다. 이 NPU의 성능과 효율성이 미래 AI 서비스의 성패를 좌우할 핵심 요소로 떠오르면서, 각국은 막대한 자본과 인력을 투입하고 있습니다. 한국의 경우, 메모리 분야에서는 독보적인 기술력을 자랑하지만, 시스템 반도체와 NPU 분야에서는 아직 선두 주자들을 따라잡아야 하는 상황입니다。</p>
                    <p>새로운 시장의 진입은 언제나 기회와 위험을 동시에 내포합니다. 국내 기업들이 기존의 메모리 제조 역량에 안주하지 않고, 고성능 컴퓨팅 및 엣지 AI 분야의 맞춤형 반도체 개발에 전력을 기울여야 합니다. 특히 글로벌 빅테크 기업들이 자체적으로 AI 칩을 설계하는 트렌드를 고려할 때, 한국 파운드리 기업들은 이들과의 긴밀한 협력을 통해 첨단 공정을 선제적으로 제공하는 '전략적 파트너' 역할을 강화해야 합니다. 이를 위해 초미세 공정 기술 로드맵을 가속화하고, 차세대 소재 및 패키징 기술에 대한 투자를 확대하는 것이 필수적입니다.</p>
                    <p>전문가들은 현재의 기술 경쟁 구도가 과거의 메모리 치킨 게임과는 완전히 다른 양상을 보인다고 분석합니다. 단순히 생산량을 늘리는 것이 아니라, 얼마나 빠르게 고도화된 설계 및 파운드리 기술을 결합하느냐가 승패를 가르는 열쇠라는 것입니다. 이로 인해 반도체 설계 인력에 대한 수요가 급증하고 있으며, 국내외 대학의 관련 학과들은 정원 확대 요구를 받고 있습니다. 특히 첨단 패키징 기술이 중요성이 부각되고 있으며, 칩과 메모리를 통합하는 첨단 패키징 기술이 없이는 NPU의 연산 속도를 끌어올리기 어렵기 때문입니다. 이 내용이 첫 번째 본문 광고 전에 <strong>약 1 뷰포트 높이</strong>를 확보합니다。</p>

                    <div class="dummy-data-box">
                        <h4>📊 데이터 분석: AI 칩 시장 규모 전망 (2025~2030)</h4>
                        <p>2025년 500억 달러에서 2030년 2,000억 달러 규모로 연평균 30% 이상 성장 예상. (출처: 글로벌 리서치 기관)</p>
                        <p>주요 성장 동력: 클라우드 AI 서비스, 엣지 AI 디바이스, 자율주행 차량용 칩. 이 박스 역시 뷰포트 확보에 기여합니다。</p>
                    </div>

                    <div id="MC_article_rectangle_1" class="ad-slot ad-mc-article"></div>

                    <p>전문가들은 현재의 기술 경쟁 구도가 과거의 메모리 치킨 게임과는 완전히 다른 양상을 보인다고 분석합니다. 단순히 생산량을 늘리는 것이 아니라, 얼마나 빠르게 고도화된 설계 및 파운드리 기술을 결합하느냐가 승패를 가르는 열쇠라는 것입니다. 이로 인해 반도체 설계 인력에 대한 수요가 급증하고 있으며, 국내외 대학의 관련 학과들은 정원 확대 요구를 받고 있습니다. 특히 첨단 패키징 기술이 중요성이 부각되고 있으며, 칩과 메모리를 통합하는 첨단 패키징 기술이 없이는 NPU의 연산 속도를 끌어올리기 어렵기 때문입니다. 이 내용이 첫 번째 본문 광고 전에 <strong>약 1 뷰포트 높이</strong>를 확보합니다。</p>
                    <p>새로운 시장의 진입은 언제나 기회와 위험을 동시에 내포합니다. 국내 기업들이 기존의 메모리 제조 역량에 안주하지 않고, 고성능 컴퓨팅 및 엣지 AI 분야의 맞춤형 반도체 개발에 전력을 기울여야 합니다. 특히 글로벌 빅테크 기업들이 자체적으로 AI 칩을 설계하는 트렌드를 고려할 때, 한국 파운드리 기업들은 이들과의 긴밀한 협력을 통해 첨단 공정을 선제적으로 제공하는 '전략적 파트너' 역할을 강화해야 합니다. 이를 위해 초미세 공정 기술 로드맵을 가속화하고, 차세대 소재 및 패키징 기술에 대한 투자를 확대하는 것이 필수적입니다。</p>

                    <p><strong>[본문 3: 글로벌 경쟁과 결론]</strong> 글로벌 시장의 요구에 발맞춰 한국의 주요 반도체 기업들은 파운드리(위탁생산) 부문에서 초미세 공정을 경쟁적으로 도입하며 NPU 생산 능력을 강화하고 있습니다. 또한, 고대역폭 메모리(HBM)와 같은 차세대 메모리 기술을 AI 반도체와 결합하여 고성능을 구현하는 데 집중하고 있습니다. 이러한 혁신적인 접근 방식이 성공한다면, 한국은 AI 반도체 생태계에서 매우 중요한 위치를 차지할 수 있을 것으로 기대됩니다. 앞으로 2~3년이 AI 반도체 시장의 향방을 가를 중요한 시점이 될 것입니다。</p>

                    <div id="MC_article_rectangle_2" class="ad-slot ad-mc-article"></div>

                    <p>글로벌 인공지능 시장은 끊임없이 진화하고 있으며, 특히 하드웨어 분야에서는 엔비디아와 AMD, 그리고 구글, 아마존 같은 빅테크 기업들이 자체 칩 개발에 막대한 투자를 진행하고 있습니다. 이러한 경쟁 구도는 한국 반도체 산업에 새로운 기회와 동시에 위협을 제공합니다. 국내 기업들은 메모리 기술력뿐만 아니라, 시스템 반도체 설계 및 파운드리 역량을 고도화하여 칩 제조 생태계 전반의 경쟁력을 확보해야 합니다. 이는 단순히 기술 개발을 넘어, 글로벌 공급망 내에서 필수 불가결한 파트너로 자리매김하는 전략적 목표를 필요로 합니다.</p>
                    <p>반도체 산업의 미래는 '데이터 처리 속도'와 '전력 효율성'에 달려 있습니다. 특히 AI 서버의 전력 소모 문제는 환경적, 경제적 이슈로 부상하고 있어, 저전력 NPU 개발 경쟁이 심화되고 있습니다. 한국은 팹리스(설계), 파운드리(제조), 메모리(HBM)를 아우르는 수직적 협력 구조를 강화하여, 이 세 분야를 결합한 최적의 AI 반도체 솔루션을 세계 시장에 공급할 수 있는 잠재력을 극대화해야 합니다. 이는 단순히 기술 개발을 넘어, 글로벌 공급망 내에서 필수 불가결한 파트너로 자리매김하는 전략적 목표를 필요로 합니다. 이를 위해 초미세 공정 기술 로드맵을 가속화하고, 차세대 소재 및 패키징 기술에 대한 투자를 확대하는 것이 필수적이다.</p>

                    <div id="MC_article_rectangle_3" class="ad-slot ad-mc-article"></div>

                    <p>정부는 AI 반도체 개발의 전주기적 지원을 위해 대규모 국가 연구개발(R&D) 프로젝트를 추진하고, 민간 투자 리스크를 완화하기 위한 세제 혜택 및 금융 지원을 확대해야 합니다. 특히 시스템 반도체 분야는 인프라 구축에 막대한 초기 비용이 들기 때문에, 공공 파운드리 시설의 개방 및 활용도를 높여 중소 팹리스 기업의 진입 장벽을 낮추는 것도 중요합니다. 또한, 국제 표준 선점을 위해 주요 기술 동맹에 적극적으로 참여하고, 수출 규제 등 글로벌 공급망의 불확실성에 대비하는 외교적 역량도 강화해야 합니다.</p>
                    <p>AI 반도체가 미래 산업의 핵심 동력인 만큼, 반도체 제조뿐만 아니라 소프트웨어 및 알고리즘과의 결합을 통한 '토털 솔루션' 제공 능력을 갖추는 것이 필수입니다. 국내 기업들은 NPU 성능을 최적화하는 전용 AI 소프트웨어 플랫폼을 구축하고, 고객사의 다양한 요구사항에 빠르게 대응할 수 있는 유연성을 확보해야 합니다. 이러한 노력들이 결실을 맺는다면, 한국은 AI 반도체 분야에서 명실상부한 기술 강국으로 도약할 수 있을 것입니다：</p>

                    <div class="article-embed">
                        <div class="embed-wrapper">
                            <iframe
                                src="https://www.youtube.com/embed/F0XOK4n6-e4"
                                title="YouTube 영상: AI 반도체 시장 분석"
                                frameborder="0"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                referrerpolicy="strict-origin-when-cross-origin"
                                allowfullscreen>
                            </iframe>
                        </div>
                        <p class="embed-caption">관련 영상: 글로벌 AI 반도체 시장 동향</p>
                    </div>

                    <div id="MC_article_rectangle_4" class="ad-slot ad-mc-article"></div>

                    <p>새로운 기술의 물결은 멈추지 않습니다. 인공지능의 발전 속도에 발맞춰, 양자 컴퓨팅, 뉴로모픽 칩 등 차세대 반도체 기술에 대한 선도적인 연구가 병행되어야 합니다. 정부와 민간은 장기적인 관점에서 기초 과학 연구에 대한 투자를 강화하고, 실패를 용인하는 혁신적인 연구 문화를 조성함으로써, 미래 반도체 기술의 '씨앗'을 뿌려야 합니다. 이러한 선순환 구조를 통해 한국은 단순히 패스트 팔로워가 아닌, 기술 혁신을 주도하는 리더 국가로 자리매김할 수 있을 것입니다。</p>
                    <p>궁극적으로, 고성능 컴퓨팅(HPC)과 엣지 디바이스(Edge Device)를 위한 저전력 고효율 NPU 개발이 핵심 과제입니다. 서버급 AI 칩뿐만 아니라, 모바일, 자율주행, IoT 등 다양한 분야에서 맞춤형 칩 수요가 증가하고 있기 때문입니다. 이를 위해 정부 차원의 R&D 지원과 함께, 국내 반도체 학과 및 연구소의 인력 양성 프로그램 확대가 시급합니다. 인재 확보야말로 장기적인 '초격차'를 유지할 수 있는 근본적인 힘입니다。</p>
                    <p>최근에는 칩렛(Chiplet) 기술과 첨단 패키징(Advanced Packaging) 기술의 중요성이 더욱 부각되고 있습니다. 서로 다른 기능을 하는 반도체를 하나의 패키지에 통합하여 성능을 극대화하는 이 기술은 AI 칩의 성능을 결정하는 핵심 요소가 되었습니다. 한국 기업들은 HBM과 같은 독보적인 메모리 기술을 활용하여, 칩렛 기반의 고성능 AI 반도체 솔루션을 세계 시장에 선제적으로 제시해야 합니다. 이는 메모리 강국에서 AI 반도체 강국으로 도약하는 중요한 분기점이 될 것입니다。</p>
                    <p>또한, AI 반도체 스타트업 생태계 활성화가 필요합니다. 대기업의 파운드리 역량과 유망 스타트업의 혁신적인 NPU 설계 아이디어가 결합될 때 시너지가 발생합니다. 정부는 스타트업이 초기 개발 단계에서 겪는 테스트베드 접근성 문제나 자금 조달 문제를 해소하는 데 집중해야 합니다. 궁극적으로, 한국이 AI 반도체 분야에서 글로벌 리더십을 확보하기 위해서는 민간의 혁신 의지와 정부의 전략적 지원이 유기적으로 결합되는 'K-칩스 동맹'이 필수적입니다. 향후 5년이 한국 반도체 산업의 미래 50년을 좌우할 중요한 시기가 될 것입니다.</p>

                    <p><strong>[본문 4: 미래 전망과 정책 방향]</strong> AI 반도체 시장의 승자는 기술력과 더불어 '생태계 확장' 능력에 따라 결정될 것입니다. 단순히 칩의 성능을 높이는 것을 넘어, 그 칩을 활용할 수 있는 소프트웨어 플랫폼과 개발자 커뮤니티를 얼마나 빠르게 구축하느냐가 중요합니다. 엔비디아의 CUDA 생태계처럼, 한국형 AI 칩도 자체적인 소프트웨어 인프라를 구축하고, 국내외 개발자들에게 개방하여 활용도를 높여야 합니다. 이를 위해, 국내 기업들은 오픈소스 기반의 AI 플랫폼 개발에 적극 참여하고, 협력사들과의 데이터 공유 및 공동 개발을 위한 협의체를 구성하는 것이 시급합니다.</p>
                    <p>또한, 국제적인 협력과 외교적 노력이 뒷받침되어야 합니다. 미국과 중국 간의 기술 패권 경쟁이 심화되는 상황에서, 한국은 특정 국가에 종속되지 않고 안정적인 공급망을 유지할 수 있는 '전략적 자율성'을 확보해야 합니다. 핵심 소재, 부품, 장비(소부장)에 대한 국산화율을 높이는 동시에, 미국, 유럽 등 우방국과의 반도체 동맹을 강화하여 기술 표준 및 수출 규제 대응 능력을 키워야 합니다. 이는 단기적인 성과보다는 장기적인 국가 안보 및 산업 경쟁력 차원에서 접근해야 할 문제입니다.</p>
                    <p>교육 시스템의 혁신도 필수적입니다. AI 반도체 산업이 요구하는 융합적 사고와 실무 능력을 갖춘 인재를 양성하기 위해, 대학 교육 과정에 AI, 반도체 설계, 소프트웨어 코딩을 통합하는 새로운 커리큘럼 도입이 절실합니다. 정부는 계약학과, 특성화 대학원 등 인력 양성 프로그램을 확대하고, 기업들에게 인재 채용 및 교육에 대한 강력한 인센티브를 제공해야 합니다. 결국, 반도체는 '사람'이 만드는 것이며, 우수한 인재만이 미래의 기술 패권을 쥘 수 있는 열쇠입니다。</p>

                    <div id="MC_article_rectangle_5" class="ad-slot ad-mc-article"></div>
                    <div id="MC_article_rectangle_6" class="ad-slot ad-mc-article"></div>
                    <div id="MC_article_rectangle_7" class="ad-slot ad-mc-article"></div>
                    <div id="MC_article_rectangle_8" class="ad-slot ad-mc-article"></div>

                    <p>최종적으로, AI 반도체 분야에서의 한국의 성공은 <strong>'속도'와 '협력'</strong>에 달려 있습니다. 혁신 기술 개발의 속도를 높이고, 정부-대기업-스타트업 간의 유기적인 협력 체계를 구축하여, 글로벌 시장의 변화에 기민하게 대응해야 합니다. 2020년대 후반은 한국 반도체 산업이 메모리 강국을 넘어 <strong>AI 칩 생태계의 핵심 리더</strong>로 도약할 마지막 기회입니다. [끝]</p>
                </div>

                <div class="like-share-section">
                    <p>이 기사가 마음에 들었다면, 좋아요를 눌러주세요。</p>
                    <div class="like-share-button">👍 좋아요 (128)</div>
                </div>

                <div id="BC_byline_rectangle" class="ad-slot ad-bc-byline" data-googletag-enabled="false"></div>

                <div class="comment-section">
                    <h3>전체 댓글 리스트 (158개)</h3>
                    <div class="comment-item"><p><strong>독자A</strong>: 정말 중요한 내용입니다. 인재 육성이 핵심이죠!</p><p style="text-align: right; color: #aaa;">2025.10.31</p></div>
                    <div class="comment-item"><p><strong>독자B</strong>: 파운드리 기술의 경쟁력 확보가 시급합니다。</p><p style="text-align: right; color: #aaa;">2025.10.31</p></div>
                    <div class="comment-item"><p><strong>독자C</strong>: 본문 내 광고 배치가 깔끔하네요。</p><p style="text-align: right; color: #aaa;">2025.10.31</p></div>
                    <div class="comment-item"><p><strong>독자D</strong>: AI 반도체 개발은 미래 산업의 핵심 동력입니다.</p><p style="text-align: right; color: #aaa;">2025.10.31</p></div>
                    <div class="comment-item" style="border-bottom: none;"><p><strong>독자E</strong>: 국내 기업들의 적극적인 투자가 필요합니다.</p><p style="text-align: right; color: #aaa;">2025.10.31</p></div>
                    <div style="text-align: center; margin-top: 10px; font-weight: bold; color: #0056b3; cursor: pointer;">
                        전체 댓글 보기 (더보기)
                    </div>
                </div>

                <div id="BC_billboard_rectangle" class="ad-slot ad-bc-comment" data-googletag-enabled="false"></div>

                <div class="extra-content-section">
                    <h3>🔥 인기뉴스</h3>
                    <ul class="popular-news-list">
                        <li><span class="rank">1</span><span class="title">주식 시장, 금리 인상 종료 기대감에 강세 마감</span></li>
                        <li><span class="rank">2</span><span class="title">대규모 신도시 개발 계획 발표, 지역 부동산 시장 요동</span></li>
                        <li><span class="rank">3</span><span class="title">세계 경제, 고금리 시대 장기화 우려</span></li>
                        <li><span class="rank">4</span><span class="title">부동산 시장, 급매물 소진되며 거래량 회복세</span></li>
                        <li><span class="rank">5</span><span class="title">AI 기술, 제조업 혁신 주도... 생산성 획기적 개선</span></li>
                        <li><span class="rank">6</span><span class="title">국내 스타트업, 시리즈 C 투자 유치 성공</span></li>
                        <li><span class="rank">7</span><span class="title">친환경 에너지 전환, 정부 정책 추진 가속화</span></li>
                    </ul>
                </div>
            </div>

            <div class="related-area">

                <div class="related-box">
                    <h4>**이 시각 주요 뉴스** (10개로 확장)</h4>
                    <ul class="related-list">
                        <li class="article-item"><a href="#">금리 추가 인상 없을 듯... 가계 부담 완화 기대</a></li>
                        <li class="article-item"><a href="#">주요 기업, 하반기 채용 규모 전년 대비 20% 확대</a></li>

                        <li id="BC_native_list_1" class="native-ad-list-item" data-googletag-enabled="false"></li>

                        <li class="article-item"><a href="#">정부, 청년 주거 정책 특별 대책 발표</a></li>
                        <li class="article-item"><a href="#">글로벌 증시, AI 기술주 실적에 따라 희비 교차</a></li>

                        <li id="BC_native_list_2" class="native-ad-list-item" data-googletag-enabled="false"></li>

                        <li class="article-item"><a href="#">유럽 경제, 긴축 완화 시그널 포착</a></li>
                    </ul>
                </div>

                <div id="MR_side_rail_X" class="ad-slot ad-mr" data-googletag-enabled="false">
                    <script>
                        googletag.cmd.push(function () {
                            if (typeof MR_side_rail_X_slot !== 'undefined' && MR_side_rail_X_slot !== null) {
                                googletag.display('MR_side_rail_X');
                            }
                        });
                    </script>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p style="text-align: center; padding: 15px; background-color: #f7f7f7; color: #777; margin-top: 0; border-top: 1px solid #eee;">
            &copy; 2025 News View Mockup.
        </p>
    </footer>

    <script>
        // ----------------------------------------------------------
        // [Lazy Load 인프라: 공통 메커니즘 설명]
        //
        // - 이 블록은 View/Home/Section/List GPT에서 공통으로 사용할 수 있는
        //   IntersectionObserver 기반 Lazy Load 구현 패턴입니다.
        //
        // - 💡 [수정 작업 5] 최적화: 소수의 FALSE(즉시 로드) 슬롯만 관리하는 제외 방식
        //   · LAZY_AD_SLOT_IDS (상수) → EAGER_AD_SLOT_IDS (관리 포인트)로 변경
        //   · 제외 목록에 없는 슬롯만 자동으로 Lazy Load 대상으로 수집
        //
        // - 구성 요소:
        //   · EAGER_AD_SLOT_IDS     : 즉시 로드(Eager) 대상 광고 div id 리스트
        //   · lazyAdSlotsHTML       : DOM에서 관찰할 실제 요소 목록 (자동 수집)
        //   · lazyGamSlots          : GAM에 정의된 슬롯 객체 목록 (자동 수집)
        //   · lazyObserver          : IntersectionObserver 인스턴스
        //
        // - 동작 흐름:
        //   1) DOMContentLoaded 시:
        //      · setupInArticleAds()            → 본문 내 in-article 슬롯 재배치
        //      · shufflePopularNewsNativeAds()  → 우측 Native 광고 셔플 먼저 실행 (DOM 위치 확정)
        //      · setupLazyLoading()             → Lazy 대상 자동 수집 (EAGER 제외) + Eager 슬롯 즉시 refresh
        //      · startObservingLazySlots()      → IntersectionObserver 관찰 시작
        //   2) 사용자가 스크롤해서 광고 div가 뷰포트 근처에 도달하면:
        //      · observer 콜백에서 해당 slotId에 대해
        //        googletag.display(slotId) + pubads().refresh([slot]) 호출
        //   3) 한 번 로드된 슬롯은 unobserve 처리하여 중복 호출 방지
        // ----------------------------------------------------------

        // 1. 디바이스 카테고리 확인 로직 재사용 (Head script와 로직 일치)
        const userAgent = navigator.userAgent.toLowerCase();
        const width = window.innerWidth;
        const isDesktop = !(/mobile|android|iphone|ipod/.test(userAgent) && !/ipad/.test(userAgent)) && width > 1024;

        // 💡 [수정 작업 5] 즉시 로딩(Eager)이 필요한 슬롯만 정의 (소수 관리)
        const EAGER_AD_SLOT_IDS = [
            'TC_billboard_leaderboard', // 상단 빌보드 (Home/Section 등에서 사용, 안전장치)
            'TC_billboard_X'            // View 상단 빌보드
        ];

        // 💡 [수정 작업 3, 5] 데스크톱일 때 추가로 즉시 로드할 슬롯들 반영
        if (isDesktop) {
            EAGER_AD_SLOT_IDS.push('MR_side_rail_X'); // 우측 레일
            EAGER_AD_SLOT_IDS.push('BC_native_list_1', 'BC_native_list_2'); // Native 리스트 광고 (데스크톱 Eager)
        }

        let lazyAdSlotsHTML = []; 
        let lazyGamSlots = [];    
        let lazyObserver = null;  

        // ==========================================================
        // 함수 1. 본문 in-article 광고 동적 주입
        //
        // [핵심 개념 정리]
        // - 목적:
        //   · 기사마다 본문 길이/구성이 달라져도,
        //     in-article 광고가 "적절한 간격"으로 노출되도록 동적으로 위치를 계산합니다.
        //
        // - 기준:
        //   · "텍스트 높이"만을 누적하여, 순수 텍스트 기준 거리로 뷰포트 간격을 계산합니다.
        //   · 이미지/영상/데이터박스 등 시각 블록은 거리 계산에서는 제외하되,
        //     "이후 광고 최소 간격"을 따로 적용합니다.
        //
        // - 규칙:
        //   1) 짧은 기사(totalTextHeight < 1 뷰포트):
        //      · 가장 마지막 본문 블록 뒤에 MC_article_rectangle_1 하나만 삽입
        //      · 나머지 in-article 슬롯(MC_article_rectangle_2~8)은 DOM 제거 + GAM 슬롯 destroy
        //
        //   2) 일반 기사:
        //      · 광고 간 최소 간격: VIEWPORT_GAP_BETWEEN_ADS (1.0 뷰포트)
        //      · 마지막 시각 블록 이후 최소 간격: VIEWPORT_AFTER_VISUAL_MIN (0.5 뷰포트)
        //      · 시각 블록(이미지/iframe/테이블 등) 바로 위/아래에는 광고를 붙이지 않음
        //        (독자 경험 보호)
        //
        // - 기사 내용 변경 시:
        //   · 이 JS는 "현재 렌더된 .article-body DOM 상태"를 기준으로만 계산합니다.
        //   · CMS에서 본문 구조가 변하거나 문단이 늘어나는 경우에도,
        //     페이지 로딩 시점에 다시 계산되므로 새로운 본문 구조에 맞게 배치됩니다.
        // ==========================================================
        function setupInArticleAds() {
            const MC_IN_ARTICLE_SLOT_IDS = [
                'MC_article_rectangle_1',
                'MC_article_rectangle_2',
                'MC_article_rectangle_3',
                'MC_article_rectangle_4',
                'MC_article_rectangle_5',
                'MC_article_rectangle_6',
                'MC_article_rectangle_7',
                'MC_article_rectangle_8'
            ];

            const articleBody = document.querySelector('.article-body');
            if (!articleBody) return;

            const viewportHeight = window.innerHeight || 800;

            // in-article 광고 간격 정책 (뷰포트 기준)
            const VIEWPORT_GAP_BETWEEN_ADS = 1.0;   // 광고 간 최소 간격: 텍스트 기준 1 뷰포트
            const VIEWPORT_AFTER_VISUAL_MIN = 0.5;  // 시각 블록 이후 최소 간격: 텍스트 기준 0.5 뷰포트

            // 시각 블록 판별용 클래스 목록
            const VISUAL_BLOCK_CLASSES = [
                'article-image',   // 본문 이미지 래퍼
                'article-embed',   // YouTube 등 외부 임베드 래퍼
                'dummy-data-box',  // 데이터/통계 박스
                'visual-block',    // 공통 시각 블록 마커 (향후 확장용)
                'data-table',      // 데이터 테이블 래퍼
                'chart-box'        // 차트/그래프 래퍼
            ];

            // 시각 블록 판별 유틸
            const isVisualBlock = (el) => {
                if (!el) return false;

                // 클래스 기반
                if (VISUAL_BLOCK_CLASSES.some(cls => el.classList.contains(cls))) {
                    return true;
                }

                // 태그 기반 (figure, table, iframe, video 등)
                if (el.matches('figure, table, iframe, video')) {
                    return true;
                }

                return false;
            };

            // 실제 본문 블록 수집
            const contentBlocks = Array.from(
                articleBody.querySelectorAll(
                    'p, .article-image, .article-embed, .dummy-data-box, ' +
                    'figure, table, iframe, video, .data-table, .chart-box'
                )
            );

            // 텍스트 높이만 누적하여 앵커 정보 생성
            let cumulativeTextHeight = 0;
            const anchors = contentBlocks.map(el => {
                const visual = isVisualBlock(el);
                let textHeight = 0;

                // 시각 블록(이미지/Embeds/데이터박스/테이블 등)의 높이는
                // "뷰포트 계산"에서 제외 → 순수 텍스트 기준 거리만 본다.
                if (!visual) {
                    const rect = el.getBoundingClientRect();
                    textHeight = rect.height || el.offsetHeight || 0;
                    cumulativeTextHeight += textHeight;
                }

                return {
                    element: el,
                    isVisual: visual,
                    textHeight,
                    cumulativeTextHeight
                };
            });

            const totalTextHeight = anchors.length > 0
                ? anchors[anchors.length - 1].cumulativeTextHeight
                : 0;

            const isShortArticle = totalTextHeight < viewportHeight;
            const lastContentBlock = anchors.length > 0
                ? anchors[anchors.length - 1].element
                : null;

            // 실제로 사용된 in-article 광고 슬롯 ID 기록
            const placedSlotIds = new Set();

            // ---- 짧은 기사 예외 처리 ----
            if (isShortArticle && lastContentBlock) {
                const firstSlotId = MC_IN_ARTICLE_SLOT_IDS[0];
                const firstSlotEl = document.getElementById(firstSlotId);

                if (firstSlotEl) {
                    if (lastContentBlock.nextSibling) {
                        articleBody.insertBefore(firstSlotEl, lastContentBlock.nextSibling);
                    } else {
                        articleBody.appendChild(firstSlotEl);
                    }
                    placedSlotIds.add(firstSlotId);
                }

                // 나머지 MC 슬롯은 사용되지 않으므로 DOM에서 제거
                MC_IN_ARTICLE_SLOT_IDS.slice(1).forEach(slotId => {
                    const el = document.getElementById(slotId);
                    if (el && el.parentElement) {
                        el.parentElement.removeChild(el);
                    }
                });

                // GPT 슬롯 객체도 함께 정리
                if (window.googletag && googletag.cmd) {
                    googletag.cmd.push(function () {
                        const allSlots = googletag.pubads().getSlots();
                        const unused = allSlots.filter(slot =>
                            MC_IN_ARTICLE_SLOT_IDS.slice(1).includes(slot.getSlotElementId())
                        );
                        if (unused.length > 0) {
                            googletag.destroySlots(unused);
                            console.log(
                                '[In-Article] Short article – destroyed unused slots:',
                                unused.map(s => s.getSlotElementId()).join(', ')
                            );
                        }
                    });
                }

                if (isShortArticle && lastContentBlock) return;
            }

            // ---- 일반 기사 케이스 ----
            if (!isShortArticle && anchors.length > 0) {
                // 마지막 블록 뒤에는 광고를 넣지 않기 위해, 마지막 앵커는 후보에서 제외
                const anchorsForPlacement = anchors.length > 1 ? anchors.slice(0, -1) : [];

                let lastAdTextHeight = 0;             // 마지막 광고 기준 텍스트 누적 높이
                let lastVisualTextHeight = -Infinity; // 마지막 시각 블록 등장 시점(텍스트 기준)
                let slotIndex = 0;                    // 사용할 MC 슬롯 인덱스

                const findNonAdPrevSibling = (el) => {
                    let prev = el.previousElementSibling;
                    // 이전 형제 중 ad-slot은 건너뛰고 실제 콘텐츠 블록을 찾는다
                    while (prev && prev.classList.contains('ad-slot')) {
                        prev = prev.previousElementSibling;
                    }
                    return prev;
                };

                const findNonAdNextSibling = (el) => {
                    let next = el.nextElementSibling;
                    // 다음 형제 중 ad-slot은 건너뛰고 실제 콘텐츠 블록을 찾는다
                    while (next && next.classList.contains('ad-slot')) {
                        next = next.nextElementSibling;
                    }
                    return next;
                };

                for (let i = 0; i < anchorsForPlacement.length; i++) {
                    if (slotIndex >= MC_IN_ARTICLE_SLOT_IDS.length) break;

                    const a = anchorsForPlacement[i];

                    // 시각 블록(이미지/Embeds/데이터박스/테이블 등)인 경우:
                    // 텍스트 높이는 누적 X, "여기서 시각 블록이 나왔다"는 기준만 기록
                    if (a.isVisual) {
                        lastVisualTextHeight = a.cumulativeTextHeight;
                        continue;
                    }

                    // 이 텍스트 블록까지의 누적 텍스트 높이
                    const textSinceLastAd = a.cumulativeTextHeight - lastAdTextHeight;
                    const textSinceLastVisual = a.cumulativeTextHeight - lastVisualTextHeight;

                    // 광고 간 최소 간격: 텍스트 기준 VIEWPORT_GAP_BETWEEN_ADS 뷰포트 이상
                    if (textSinceLastAd < viewportHeight * VIEWPORT_GAP_BETWEEN_ADS) continue;

                    // 마지막 시각 블록 이후 최소 VIEWPORT_AFTER_VISUAL_MIN 뷰포트 텍스트 확보
                    if (textSinceLastVisual < viewportHeight * VIEWPORT_AFTER_VISUAL_MIN) continue;

                    // 위/아래 인접 요소가 시각 블록이면 이번 위치는 스킵
                    const prevSibling = findNonAdPrevSibling(a.element);
                    const nextSibling = findNonAdNextSibling(a.element);

                    if ((prevSibling && isVisualBlock(prevSibling)) ||
                        (nextSibling && isVisualBlock(nextSibling))) {
                        // 👉 "위/아래 중 하나라도 이미지/Embeds/데이터박스/테이블이라면 이번엔 참는다"
                        continue;
                    }

                    // 위 조건을 모두 만족하면, 현재 텍스트 블록 앞에 광고 슬롯 삽입
                    const slotId = MC_IN_ARTICLE_SLOT_IDS[slotIndex];
                    const slotEl = document.getElementById(slotId);

                    if (!slotEl) {
                        slotIndex++;
                        continue;
                    }

                    articleBody.insertBefore(slotEl, a.element);
                    placedSlotIds.add(slotId);

                    // 마지막 광고 기준 텍스트 누적 높이 갱신
                    lastAdTextHeight = a.cumulativeTextHeight;
                    slotIndex++;
                }

                // 사용되지 않은 MC in-article 슬롯 정리
                const unusedSlotIds = MC_IN_ARTICLE_SLOT_IDS.filter(id => !placedSlotIds.has(id));

                // DOM에서 제거
                unusedSlotIds.forEach(slotId => {
                    const el = document.getElementById(slotId);
                    if (el && el.parentElement) {
                        el.parentElement.removeChild(el);
                    }
                });

                // GPT 슬롯 객체도 destroySlots로 정리
                if (window.googletag && googletag.cmd) {
                    googletag.cmd.push(function () {
                        const allSlots = googletag.pubads().getSlots();
                        const unusedSlots = allSlots.filter(slot =>
                            unusedSlotIds.includes(slot.getSlotElementId())
                        );
                        if (unusedSlots.length > 0) {
                            googletag.destroySlots(unusedSlots);
                            console.log(
                                '[In-Article] Destroyed unused in-article slots:',
                                unusedSlots.map(s => s.getSlotElementId()).join(', ')
                            );
                        }
                    });
                }
            }
        }

        // ==========================================================
        // 함수 2. Lazy Load 대상 광고 슬롯 설정 및 Observer 생성 (💡 수정 작업 5 적용)
        //
        // - 기존: 고정된 LAZY_AD_SLOT_IDS 리스트를 순회
        // - 변경: DOM의 모든 .ad-slot을 순회하며 EAGER_AD_SLOT_IDS에 없는 것만 자동 수집 (Blacklist 방식)
        // ==========================================================
        function setupLazyLoading() {
            // 1) DOM 상에서 Lazy 대상 슬롯 수집 (제외 리스트 방식 적용)
            const allAdSlots = document.querySelectorAll('.ad-slot, .native-ad-list-item');
            lazyAdSlotsHTML = [];

            allAdSlots.forEach(slot => {
                // ⭐ 수정: ID가 EAGER_AD_SLOT_IDS에 '포함되지 않은' 것만 Lazy 대상으로 등록
                if (slot.id && !EAGER_AD_SLOT_IDS.includes(slot.id)) {
                    lazyAdSlotsHTML.push(slot);
                }
            });

            // 2) GAM 슬롯 객체 필터링 (제외 리스트 방식 적용)
            lazyGamSlots = [];
            if (window.googletag && googletag.cmd) {
                googletag.cmd.push(function () {
                    const definedSlots = googletag.pubads().getSlots();
                    
                    // ⭐ 수정: 제외 목록에 없는 슬롯만 필터링하여 lazyGamSlots에 저장
                    lazyGamSlots = definedSlots.filter(slot =>
                        !EAGER_AD_SLOT_IDS.includes(slot.getSlotElementId())
                    );

                    // [추가 기능] 즉시 로드 대상(Eager)은 이 시점에 바로 refresh 호출
                    const eagerSlots = definedSlots.filter(slot =>
                        EAGER_AD_SLOT_IDS.includes(slot.getSlotElementId())
                    );
                    if (eagerSlots.length > 0) {
                        // TC_billboard_X 등 이미 상단에서 호출된 것과 중복되지 않도록 refresh
                        // (필요 시 중복 호출 방지 로직 추가 가능, 여기서는 명시적 호출 보장)
                        // 단, display()는 body 내 script에서 이미 처리됨을 가정하거나 확인 필요
                        googletag.pubads().refresh(eagerSlots);
                        console.log("⚡ [Eager Load] Immediate refresh for:", eagerSlots.map(s => s.getSlotElementId()));
                    }
                });
            }

            /**
             * [객관적 최적화: 디바이스별 rootMargin 동적 할당]
             * - 한국의 안정적인 네트워크 인프라와 사용자 스크롤 속도를 고려한 '스윗 스팟' 수치 적용
             * - Smartphone: 600px (빠른 플릭 스크롤 대응)
             * - Tablet: 500px (넓은 화면비 고려)
             * - Desktop: 400px (글로벌 미디어 표준값)
             */
            // --- IntersectionObserver 옵션 설정 (디바이스별 rootMargin 최적화) ---

            const ua = navigator.userAgent.toLowerCase();
            const width = window.innerWidth;
            let marginValue = '400px'; // Desktop 기본값

            // 1. Smartphone 판별 로직 적용 (Mobile UA이면서 iPad가 아니거나, 폭이 768px 이하)
            if ((/mobile|android|iphone|ipod/.test(ua) && !/ipad/.test(ua)) || width <= 768) {
                marginValue = '600px'; // Smartphone: 모바일의 빠른 스크롤을 고려하여 가장 넓은 여백 설정
            } 
            // 2. Tablet 판별 로직 적용 (iPad/Tablet UA이거나, 폭이 1024px 이하)
            else if (/ipad|tablet/.test(ua) || width <= 1024) {
                marginValue = '500px'; // Tablet: 중간 정도의 여백 설정
            }
            // 3. 그 외: Desktop (기본값 400px 유지)
            // IntersectionObserver 생성
            /*
             * - root      : null → 브라우저 viewport 기준
             * - rootMargin: 동적으로 할당된 marginValue 적용
             * → 실제 뷰포트 하단보다 지정된 픽셀만큼 앞서 미리 로딩 시작(프리로딩 효과)
             * - threshold : 0.0
             * → 요소가 1px만 보이기 시작해도 isIntersecting === true
             */
            const options = {
                root: null,
                rootMargin: `0px 0px ${marginValue} 0px`, // 하단 여백을 디바이스별로 다르게 적용
                threshold: 0.0
            };

            console.log(`🚀 [Lazy Load] rootMargin optimized for ${marginValue} based on device detection.`);

            lazyObserver = new IntersectionObserver(function (entries, observerInstance) {
                entries.forEach(entry => {
                    const slotId = entry.target.id;
                    if (!entry.isIntersecting) return;

                    if (window.googletag && googletag.cmd) {
                        googletag.cmd.push(function () {
                            const slotToRefresh = lazyGamSlots.find(
                                s => s.getSlotElementId() === slotId
                            );

                            if (slotToRefresh) {
                                // disableInitialLoad() 상태이므로 display + refresh로 최초 요청
                                googletag.display(slotId);
                                googletag.pubads().refresh([slotToRefresh]);
                                console.log(
                                    `✅ [Lazy Load SUCCESS] Ad ID: ${slotId} | Status: GAM DISPLAYED & REFRESHED upon Scroll.`
                                );
                            }
                        });
                    }

                    observerInstance.unobserve(entry.target);
                });
            }, options);
        }

        // ==========================================================
        // 함수 3. "이 시각 주요 뉴스" 내 Native Ad 슬롯 랜덤 배치
        //
        // - 요구사항 정리
        //   · 뉴스 목록(기사 LI)의 "순서"와 "번호"는 항상 고정
        //     → HTML에 정의된 기사 순서를 그대로 유지
        //   · 광고 LI(BC_native_list_1, BC_native_list_2)만
        //     기사 사이의 여러 후보 위치 중 랜덤하게 삽입
        //   · CSS 카운터 구조와 결합하여
        //     기사 번호는 1~5로 연속 유지, 광고는 별도 라벨 없이 노출
        //
        // - 구현 방식
        //   1) UL(.related-list) 하위 LI를 기사/광고로 분리
        //   2) 기사 LI 배열(articleItems)의 순서는 절대 변경하지 않음
        //   3) "기사 사이 틈(gap)" 목록을 구성
        //      · gap index = 1 ~ (기사 개수 - 1)
        //      · 예: 기사 5개 → gap 후보는 [1,2,3,4]
        //      · gap = 2 라는 의미는 "2번 기사 뒤"를 의미
        //   4) 광고 개수만큼 gap을 랜덤 선택 + 광고 배열 자체도 랜덤 셔플
        //   5) 새 UL을 구성할 때:
        //      · 기사 i를 append
        //      · 만약 i 뒤에 광고를 넣기로 한 gap이면, 그 다음에 광고 LI를 append
        //
        // - 결과
        //   · 기사 노출 순서/번호: 항상 동일
        //   · 광고 위치/순서: 페이지 로드마다 무작위
        // ==========================================================
        function shufflePopularNewsNativeAds() {
            const relatedList = document.querySelector('.related-list');
            if (!relatedList) return;

            const allItems = Array.from(relatedList.children);
            const isAd = (item) => item.id && item.id.startsWith('BC_native');

            const articleItems = allItems.filter(item => !isAd(item));
            const adItems = allItems.filter(item => isAd(item));

            // 기사 또는 광고가 아예 없으면 로직 수행 의미가 없음
            if (articleItems.length === 0 || adItems.length === 0) {
                return;
            }

            // 기존 내용 초기화
            relatedList.innerHTML = '';

            const articleCount = articleItems.length;

            // [1] "기사 사이 gap" 후보 생성 (1 ~ articleCount-1)
            //     - gap = n 이라는 의미는 "n번 기사 뒤"라는 의미
            const gapIndices = [];
            for (let i = 1; i < articleCount; i++) {
                gapIndices.push(i);
            }

            // [2] gap 후보들을 무작위 셔플(Fisher–Yates)
            const gapsShuffled = [...gapIndices];
            for (let i = gapsShuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gapsShuffled[i], gapsShuffled[j]] = [gapsShuffled[j], gapsShuffled[i]];
            }

            // [3] 광고 개수만큼 gap 사용 (gap 수보다 광고가 많으면, gap 수만큼만 사용)
            const useGapCount = Math.min(adItems.length, gapsShuffled.length);
            const selectedGaps = gapsShuffled
                .slice(0, useGapCount)
                .sort((a, b) => a - b); // 기사 순회 시 비교를 위해 오름차순 정렬

            // [4] 광고 자체 순서도 무작위 셔플
            const shuffledAds = [...adItems];
            for (let i = shuffledAds.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAds[i], shuffledAds[j]] = [shuffledAds[j], shuffledAds[i]];
            }

            let adIndex = 0;          // 다음에 사용할 광고 인덱스
            let gapIndexCursor = 0;   // selectedGaps 순회용 커서

            // [5] 기사 순서를 그대로 유지하면서, 선택된 gap 위치 뒤에만 광고 삽입
            for (let i = 0; i < articleCount; i++) {
                // (1) 기사 append
                relatedList.appendChild(articleItems[i]);

                // (2) 만약 "현재 기사(i+1) 뒤"가 선택된 gap이라면 광고 append
                if (
                    gapIndexCursor < selectedGaps.length &&
                    selectedGaps[gapIndexCursor] === i + 1 &&
                    adIndex < shuffledAds.length
                ) {
                    relatedList.appendChild(shuffledAds[adIndex]);
                    adIndex++;
                    gapIndexCursor++;
                }
            }

            // [선택적 안전장치] gap보다 광고가 더 많은 극단적 케이스:
            //  - 남은 광고가 있다면 마지막 기사 뒤에 순차적으로 붙임
            //  - 기사 순서는 여전히 변경되지 않으므로 요구사항 위배 없음
            while (adIndex < shuffledAds.length) {
                relatedList.appendChild(shuffledAds[adIndex]);
                adIndex++;
            }
        }

        // ==========================================================
        // 함수 4. Lazy Load 대상 슬롯 관찰 시작
        // ==========================================================
        function startObservingLazySlots() {
            if (!lazyObserver || !lazyAdSlotsHTML || lazyAdSlotsHTML.length === 0) return;
            lazyAdSlotsHTML.forEach(slot => {
                lazyObserver.observe(slot);
            });
        }

        // ==========================================================
        // DOMContentLoaded 시점에 주요 로직 실행
        //
        // - View GPT에서 DOMContentLoaded를 사용하는 이유:
        //   · 기사 본문(.article-body) DOM 구조가 완전히 구성된 이후에
        //     in-article 광고 위치를 계산해야 하기 때문입니다.
        //   · 이미지/임베드 등의 높이는 레이아웃에 영향을 주지만,
        //     이 로직에서는 "텍스트 기준 거리"만 누적하므로
        //     DOM이 준비된 시점에 getBoundingClientRect()를 사용하는 것이 안정적입니다.
        //
        // - 실행 순서:
        //   1) setupInArticleAds()            → 본문 내 in-article 동적 배치 + 미사용 슬롯 제거
        //   2) shufflePopularNewsNativeAds()  → (✅ 순서 변경됨) 우측 Native 광고 셔플 먼저 실행 (DOM 위치 확정)
        //   3) setupLazyLoading()             → Lazy 대상 수집 + GAM 슬롯 매핑 + Observer 생성
        //   4) startObservingLazySlots()      → IntersectionObserver 관찰 시작
        // ==========================================================
        document.addEventListener('DOMContentLoaded', function () {
            setupInArticleAds();             // 본문 in-article 광고 동적 주입
            shufflePopularNewsNativeAds();   // 우측 '이 시각 주요 뉴스' 내 Native 광고 랜덤 배치 (기사 순서 고정, 광고만 셔플)
            setupLazyLoading();              // Lazy Load 대상 수집 (Eager 제외) 및 Eager 실행
            startObservingLazySlots();       // Lazy 대상 슬롯 관찰 시작
        });
    </script>
</body>
</html>